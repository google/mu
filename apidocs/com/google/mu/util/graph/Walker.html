<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (12.0.1) on Sat Mar 09 14:47:22 PST 2024 -->
<title>Walker (core 7.3-SNAPSHOT API)</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="dc.created" content="2024-03-09">
<link rel="stylesheet" type="text/css" href="../../../../../javadoc-stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../../jquery/jquery-ui.css" title="Style">
<script type="text/javascript" src="../../../../../script.js"></script>
<script type="text/javascript" src="../../../../../jquery/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../../../../jquery/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../../../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../../../../jquery/jquery-3.3.1.js"></script>
<script type="text/javascript" src="../../../../../jquery/jquery-migrate-3.0.1.js"></script>
<script type="text/javascript" src="../../../../../jquery/jquery-ui.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="Walker (core 7.3-SNAPSHOT API)";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":6,"i1":10,"i2":9,"i3":9,"i4":9,"i5":9,"i6":6,"i7":10,"i8":6,"i9":10};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],2:["t2","Instance Methods"],4:["t3","Abstract Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../../../../";
var useModuleDirectories = true;
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/Walker.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<ul class="navListSearch">
<li><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</li>
</ul>
</div>
<a id="skip.navbar.top">
<!--   -->
</a>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">com.google.mu.util.graph</a></div>
<h2 title="Class Walker" class="title">Class Walker&lt;N&gt;</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>com.google.mu.util.graph.Walker&lt;N&gt;</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>Direct Known Subclasses:</dt>
<dd><code><a href="BinaryTreeWalker.html" title="class in com.google.mu.util.graph">BinaryTreeWalker</a></code>, <code><a href="GraphWalker.html" title="class in com.google.mu.util.graph">GraphWalker</a></code></dd>
</dl>
<hr>
<pre>public abstract class <span class="typeNameLabel">Walker&lt;N&gt;</span>
extends java.lang.Object</pre>
<div class="block">Implements generic graph and tree traversal algorithms (<a href="#preOrderFrom(N...)"><code>pre-order</code></a>,
 <a href="#postOrderFrom(N...)"><code>post-order</code></a> and <a href="#breadthFirstFrom(N...)"><code>breadth-first</code></a>) as lazily
 evaluated streams, allowing infinite-size graphs.

 <p>The following example code explores all islands to find the treasure island:

 <pre><code>
 Optional&lt;Island&gt; treasureIsland =
     Walker.inGraph(Island::nearbyIslands)
         .preOrderFrom(homeIsland)
         .filter(Island::hasTreasure)
         .findFirst();
 </code></pre>

 <p>None of these streams are safe to run in parallel. Although, multiple threads could traverse
 the same graph collaboratively by sharing a concurrent node tracker. See
 <a href="#inGraph(java.util.function.Function,java.util.function.Predicate)"><code>inGraph(findSuccessors, nodeTracker)</code></a> for details.

 <p>For binary trees, use <a href="#inBinaryTree(java.util.function.UnaryOperator,java.util.function.UnaryOperator)"><code>inBinaryTree(Tree::left, Tree::right)</code></a>.</div>
<dl>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>4.0</dd>
</dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ========== METHOD SUMMARY =========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<div class="memberSummary">
<div role="tablist" aria-orientation="horizontal"><button role="tab" aria-selected="true" aria-controls="memberSummary_tabpanel" tabindex="0" onkeydown="switchTab(event)" id="t0" class="activeTableTab">All Methods</button><button role="tab" aria-selected="false" aria-controls="memberSummary_tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t1" class="tableTab" onclick="show(1);">Static Methods</button><button role="tab" aria-selected="false" aria-controls="memberSummary_tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t2" class="tableTab" onclick="show(2);">Instance Methods</button><button role="tab" aria-selected="false" aria-controls="memberSummary_tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t3" class="tableTab" onclick="show(4);">Abstract Methods</button><button role="tab" aria-selected="false" aria-controls="memberSummary_tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t4" class="tableTab" onclick="show(8);">Concrete Methods</button></div>
<div id="memberSummary_tabpanel" role="tabpanel">
<table aria-labelledby="t0">
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tbody>
<tr class="altColor" id="i0">
<td class="colFirst"><code>abstract java.util.stream.Stream&lt;<a href="Walker.html" title="type parameter in Walker">N</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#breadthFirstFrom(java.lang.Iterable)">breadthFirstFrom</a></span>&#8203;(java.lang.Iterable&lt;? extends <a href="Walker.html" title="type parameter in Walker">N</a>&gt;&nbsp;startNodes)</code></th>
<td class="colLast">
<div class="block">Starts from <code>startNodes</code> and walks in breadth-first order.</div>
</td>
</tr>
<tr class="rowColor" id="i1">
<td class="colFirst"><code>java.util.stream.Stream&lt;<a href="Walker.html" title="type parameter in Walker">N</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#breadthFirstFrom(N...)">breadthFirstFrom</a></span>&#8203;(<a href="Walker.html" title="type parameter in Walker">N</a>...&nbsp;startNodes)</code></th>
<td class="colLast">
<div class="block">Starts from <code>startNodes</code> and walks in breadth-first order.</div>
</td>
</tr>
<tr class="altColor" id="i2">
<td class="colFirst"><code>static &lt;N&gt;&nbsp;<a href="BinaryTreeWalker.html" title="class in com.google.mu.util.graph">BinaryTreeWalker</a>&lt;N&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#inBinaryTree(java.util.function.UnaryOperator,java.util.function.UnaryOperator)">inBinaryTree</a></span>&#8203;(java.util.function.UnaryOperator&lt;N&gt;&nbsp;getLeft,
            java.util.function.UnaryOperator&lt;N&gt;&nbsp;getRight)</code></th>
<td class="colLast">
<div class="block">Returns a <code>BinaryTreeWalker</code> for walking in the binary tree topology
 as observed by <code>getLeft</code> and <code>getRight</code> functions.</div>
</td>
</tr>
<tr class="rowColor" id="i3">
<td class="colFirst"><code>static &lt;N&gt;&nbsp;<a href="GraphWalker.html" title="class in com.google.mu.util.graph">GraphWalker</a>&lt;N&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#inGraph(java.util.function.Function)">inGraph</a></span>&#8203;(java.util.function.Function&lt;? super N,&#8203;? extends java.util.stream.Stream&lt;? extends N&gt;&gt;&nbsp;findSuccessors)</code></th>
<td class="colLast">
<div class="block">Returns a <code>Walker</code> to walk the graph topology (possibly with cycles) as observed by
 the <code>findSuccessors</code> function, which finds successors of any given graph node.</div>
</td>
</tr>
<tr class="altColor" id="i4">
<td class="colFirst"><code>static &lt;N&gt;&nbsp;<a href="GraphWalker.html" title="class in com.google.mu.util.graph">GraphWalker</a>&lt;N&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#inGraph(java.util.function.Function,java.util.function.Predicate)">inGraph</a></span>&#8203;(java.util.function.Function&lt;? super N,&#8203;? extends java.util.stream.Stream&lt;? extends N&gt;&gt;&nbsp;findSuccessors,
       java.util.function.Predicate&lt;? super N&gt;&nbsp;tracker)</code></th>
<td class="colLast">
<div class="block">Similar to <a href="#inGraph(java.util.function.Function)"><code>inGraph(Function)</code></a>, returns a <code>Walker</code> that can be used to
 traverse a graph of nodes.</div>
</td>
</tr>
<tr class="rowColor" id="i5">
<td class="colFirst"><code>static &lt;N&gt;&nbsp;<a href="Walker.html" title="class in com.google.mu.util.graph">Walker</a>&lt;N&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#inTree(java.util.function.Function)">inTree</a></span>&#8203;(java.util.function.Function&lt;? super N,&#8203;? extends java.util.stream.Stream&lt;? extends N&gt;&gt;&nbsp;findChildren)</code></th>
<td class="colLast">
<div class="block">Returns a <code>Walker</code> to walk the tree topology (no cycles) as observed by the <code>
 findChildren</code> function, which finds children of any given tree node.</div>
</td>
</tr>
<tr class="altColor" id="i6">
<td class="colFirst"><code>abstract java.util.stream.Stream&lt;<a href="Walker.html" title="type parameter in Walker">N</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#postOrderFrom(java.lang.Iterable)">postOrderFrom</a></span>&#8203;(java.lang.Iterable&lt;? extends <a href="Walker.html" title="type parameter in Walker">N</a>&gt;&nbsp;startNodes)</code></th>
<td class="colLast">
<div class="block">Starts from <code>startNodes</code> and walks depth first in post-order
 (the reverse of a topological sort).</div>
</td>
</tr>
<tr class="rowColor" id="i7">
<td class="colFirst"><code>java.util.stream.Stream&lt;<a href="Walker.html" title="type parameter in Walker">N</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#postOrderFrom(N...)">postOrderFrom</a></span>&#8203;(<a href="Walker.html" title="type parameter in Walker">N</a>...&nbsp;startNodes)</code></th>
<td class="colLast">
<div class="block">Starts from <code>startNodes</code> and walks depth first in post-order
 (the reverse of a topological sort).</div>
</td>
</tr>
<tr class="altColor" id="i8">
<td class="colFirst"><code>abstract java.util.stream.Stream&lt;<a href="Walker.html" title="type parameter in Walker">N</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#preOrderFrom(java.lang.Iterable)">preOrderFrom</a></span>&#8203;(java.lang.Iterable&lt;? extends <a href="Walker.html" title="type parameter in Walker">N</a>&gt;&nbsp;startNodes)</code></th>
<td class="colLast">
<div class="block">Starts from <code>startNodes</code> and walks depth first in pre-order.</div>
</td>
</tr>
<tr class="rowColor" id="i9">
<td class="colFirst"><code>java.util.stream.Stream&lt;<a href="Walker.html" title="type parameter in Walker">N</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#preOrderFrom(N...)">preOrderFrom</a></span>&#8203;(<a href="Walker.html" title="type parameter in Walker">N</a>...&nbsp;startNodes)</code></th>
<td class="colLast">
<div class="block">Starts from <code>startNodes</code> and walks depth first in pre-order.</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ METHOD DETAIL ========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a id="inBinaryTree(java.util.function.UnaryOperator,java.util.function.UnaryOperator)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>inBinaryTree</h4>
<pre class="methodSignature">public static&nbsp;&lt;N&gt;&nbsp;<a href="BinaryTreeWalker.html" title="class in com.google.mu.util.graph">BinaryTreeWalker</a>&lt;N&gt;&nbsp;inBinaryTree&#8203;(java.util.function.UnaryOperator&lt;N&gt;&nbsp;getLeft,
                                                   java.util.function.UnaryOperator&lt;N&gt;&nbsp;getRight)</pre>
<div class="block">Returns a <code>BinaryTreeWalker</code> for walking in the binary tree topology
 as observed by <code>getLeft</code> and <code>getRight</code> functions. Both functions
 return null to indicate that there is no left or right child.

 <p>It's guaranteed that for any given node, <code>getLeft</code> and <code>getRight</code>
 are called lazily, only when the left or the right child is traversed. They are called at
 most once for each node.</div>
<dl>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>4.2</dd>
</dl>
</li>
</ul>
<a id="inTree(java.util.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>inTree</h4>
<pre class="methodSignature">public static&nbsp;&lt;N&gt;&nbsp;<a href="Walker.html" title="class in com.google.mu.util.graph">Walker</a>&lt;N&gt;&nbsp;inTree&#8203;(java.util.function.Function&lt;? super N,&#8203;? extends java.util.stream.Stream&lt;? extends N&gt;&gt;&nbsp;findChildren)</pre>
<div class="block">Returns a <code>Walker</code> to walk the tree topology (no cycles) as observed by the <code>
 findChildren</code> function, which finds children of any given tree node.

 <p><code>inTree()</code> is more efficient than <a href="#inGraph(java.util.function.Function)"><code>inGraph()</code></a> because it doesn't need
 to remember nodes that are already visited. On the other hand, the returned <code>Walker</code> can
 walk in cycles if the <code>findChildren</code> function unexpectedly represents a cyclic graph.
 If you need to guard against cycles just in case, you can use <a href="#inGraph(java.util.function.Function,java.util.function.Predicate)"><code>inGraph()</code></a> with a custom node tracker to check for the critical
 precondition:

 <pre><code>
 Set&lt;N&gt; visited = new HashSet&lt;&gt;();
 Walker&lt;N&gt; walker = Walker.inGraph(successorFunction, n -&gt; {
   checkArgument(visited.add(n), "Node with multiple parents: %s", n);
   return true;
 });
 </code></pre>

 <p>The returned object is idempotent, stateless and immutable as long as <code>findChildren</code> is
 idempotent, stateless and immutable.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>findChildren</code> - Function to get the child nodes for a given node.
        No children if empty stream or null is returned,</dd>
</dl>
</li>
</ul>
<a id="inGraph(java.util.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>inGraph</h4>
<pre class="methodSignature">public static&nbsp;&lt;N&gt;&nbsp;<a href="GraphWalker.html" title="class in com.google.mu.util.graph">GraphWalker</a>&lt;N&gt;&nbsp;inGraph&#8203;(java.util.function.Function&lt;? super N,&#8203;? extends java.util.stream.Stream&lt;? extends N&gt;&gt;&nbsp;findSuccessors)</pre>
<div class="block">Returns a <code>Walker</code> to walk the graph topology (possibly with cycles) as observed by
 the <code>findSuccessors</code> function, which finds successors of any given graph node.

 <p>Because the traversal needs to remember which node(s) have been traversed, memory usage is
 linear to the number of traversed nodes.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>findSuccessors</code> - Function to get the successor nodes for a given node.
        No successor if empty stream or null is returned,</dd>
</dl>
</li>
</ul>
<a id="inGraph(java.util.function.Function,java.util.function.Predicate)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>inGraph</h4>
<pre class="methodSignature">public static&nbsp;&lt;N&gt;&nbsp;<a href="GraphWalker.html" title="class in com.google.mu.util.graph">GraphWalker</a>&lt;N&gt;&nbsp;inGraph&#8203;(java.util.function.Function&lt;? super N,&#8203;? extends java.util.stream.Stream&lt;? extends N&gt;&gt;&nbsp;findSuccessors,
                                         java.util.function.Predicate&lt;? super N&gt;&nbsp;tracker)</pre>
<div class="block">Similar to <a href="#inGraph(java.util.function.Function)"><code>inGraph(Function)</code></a>, returns a <code>Walker</code> that can be used to
 traverse a graph of nodes. <code>tracker</code> is used to track every node being traversed. When
 <code>Walker</code> is about to traverse a node, <code>tracker.test(node)</code> will be called and the
 node (together with its edges) will be skipped if false is returned.

 <p>This is useful for custom node tracking. For example, using a <code>ConcurrentHashMap</code>,
 multiple threads can traverse a large graph concurrently and collaboratively:

 <pre><code>
 Walker&lt;Room&gt; concurrentWalker =
     Walker.inGraph(buildingMap, ConcurrentHashMap.newKeySet()::add);

 // thread 1:
 Stream&lt;Room&gt; shield = concurrentWalker.preOrderFrom(roof);
 shield.forEachOrdered(room -&gt; System.out.println("Raided by SHIELD from roof: " + room);

 // thread 2:
 Stream&lt;Room&gt; avengers = concurrentWalker.breadthFirstFrom(mainEntrance);
 avengers.forEachOrdered(room -&gt; System.out.println("Raided by Avengers: " + room);
 </code></pre>

 <p>Or, nodes can be tracked by functional equivalence. What gives?
 Imagine in a pirate treasure hunt, we start from an island and scavenge from island to island.
 Considering the islands as nodes, we can use any traversal strategy. Say, we picked pre-order:

 <pre><code>
 Optional&lt;Island&gt; treasureIsland =
     Walker.inGraph(Island::nearbyIslands)
         .preOrderFrom(startIsland)
         .filter(Island::hasTreasure)
         .findFirst();
 </code></pre>

 That gives us the treasure island. But what if upon finding the treasure island, we also want
 to make our own treasure map? It requires not just finding the island, but also recording
 how we got there. To do this, we can start by defining a class that encodes the route:

 <pre><code>
 class Route {
   private final Island island;
   private final Route predecessor;

   // End of the route.
   Island end() {
     return island;
   }

   // Returns a new Route with this Route as the predecessor.
   Route extendTo(Island newIsland) {
     return new Route(newIsland, this);
   }

   Stream&lt;Route&gt; nearbyRoutes() {
     return island.nearbyIslands().map(this::extendTo);
   }

   List&lt;Island&gt; islands() {
     // follow the `predecessor` chain to return all islands along the route.
   }
 }
 </code></pre>

 And then we can modify the treasure hunt code to walk through a stream of <code>Route</code>
 objects in place of islands. A caveat is that Route doesn't define <code>equals</code> ---
 even if it did, it'd be recursive and not what we need anyway (we care about unique islands,
 not unique routes).

 <p>Long story short, the trick is to use functional equivalence so that the <code>Walker</code>
 still knows which islands have already been searched:

 <pre><code>
 Set&lt;Island&gt; searched = new HashSet&lt;&gt;();
 Optional&lt;Route&gt; treasureIslandRoute =
     Walker.inGraph(Route::nearbyRoutes, route -&gt; searched.add(route.end()))
         .preOrderFrom(new Route(startIsland))
         .filter(route -&gt; route.end().hasTreasure())
         .findFirst();
 </code></pre>

 <p>In the case of walking a very large graph with more nodes than can fit in memory, it's
 conceivable to use <code>com.google.common.hash.BloomFilter#put BloomFilter</code> to track visited
 nodes, as long as you are okay with probabilistically missing a fraction of the graph nodes due
 to Bloom filter's inherent false-positive rates. Because Bloom filters have zero
 false-negatives, it's guaranteed that the walker will never walk in cycles.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>findSuccessors</code> - Function to get the successor nodes for a given node.
        No successor if empty stream or null is returned,</dd>
<dd><code>tracker</code> - Tracks each node being visited during traversal. Returns false if the node
        and its edges should be skipped for traversal (for example because it has already been
        traversed). Despite being a <code>Predicate</code>, the tracker usually carries
        side-effects like storing the tracked nodes in a set (<code>set::add</code>,
        <code>bloomFilter::put</code> etc. will do).</dd>
</dl>
</li>
</ul>
<a id="preOrderFrom(java.lang.Object[])">
<!--   -->
</a><a id="preOrderFrom(N...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>preOrderFrom</h4>
<pre class="methodSignature">@SafeVarargs
public final&nbsp;java.util.stream.Stream&lt;<a href="Walker.html" title="type parameter in Walker">N</a>&gt;&nbsp;preOrderFrom&#8203;(<a href="Walker.html" title="type parameter in Walker">N</a>...&nbsp;startNodes)</pre>
<div class="block">Starts from <code>startNodes</code> and walks depth first in pre-order.

 <p>The returned stream may be infinite if the graph or tree has infinite depth or infinite
 breadth, or both. The stream can still be short-circuited to consume a limited number of nodes
 during traversal.</div>
</li>
</ul>
<a id="preOrderFrom(java.lang.Iterable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>preOrderFrom</h4>
<pre class="methodSignature">public abstract&nbsp;java.util.stream.Stream&lt;<a href="Walker.html" title="type parameter in Walker">N</a>&gt;&nbsp;preOrderFrom&#8203;(java.lang.Iterable&lt;? extends <a href="Walker.html" title="type parameter in Walker">N</a>&gt;&nbsp;startNodes)</pre>
<div class="block">Starts from <code>startNodes</code> and walks depth first in pre-order.

 <p>The returned stream may be infinite if the graph or tree has infinite depth or infinite
 breadth, or both. The stream can still be short-circuited to consume a limited number of
 nodes during traversal.</div>
</li>
</ul>
<a id="postOrderFrom(java.lang.Object[])">
<!--   -->
</a><a id="postOrderFrom(N...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>postOrderFrom</h4>
<pre class="methodSignature">@SafeVarargs
public final&nbsp;java.util.stream.Stream&lt;<a href="Walker.html" title="type parameter in Walker">N</a>&gt;&nbsp;postOrderFrom&#8203;(<a href="Walker.html" title="type parameter in Walker">N</a>...&nbsp;startNodes)</pre>
<div class="block">Starts from <code>startNodes</code> and walks depth first in post-order
 (the reverse of a topological sort).

 <p>The returned stream may be infinite if the graph or tree has infinite breadth. The stream
 can still be short-circuited to consume a limited number of nodes during traversal.

 <p>The stream may result in infinite loop when traversing through a node with infinite depth.</div>
</li>
</ul>
<a id="postOrderFrom(java.lang.Iterable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>postOrderFrom</h4>
<pre class="methodSignature">public abstract&nbsp;java.util.stream.Stream&lt;<a href="Walker.html" title="type parameter in Walker">N</a>&gt;&nbsp;postOrderFrom&#8203;(java.lang.Iterable&lt;? extends <a href="Walker.html" title="type parameter in Walker">N</a>&gt;&nbsp;startNodes)</pre>
<div class="block">Starts from <code>startNodes</code> and walks depth first in post-order
 (the reverse of a topological sort).

 <p>The returned stream may be infinite if the graph or tree has infinite breadth. The stream
 can still be short-circuited to consume a limited number of nodes during traversal.

 <p>The stream may result in infinite loop when traversing through a node with infinite depth.</div>
</li>
</ul>
<a id="breadthFirstFrom(java.lang.Object[])">
<!--   -->
</a><a id="breadthFirstFrom(N...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>breadthFirstFrom</h4>
<pre class="methodSignature">@SafeVarargs
public final&nbsp;java.util.stream.Stream&lt;<a href="Walker.html" title="type parameter in Walker">N</a>&gt;&nbsp;breadthFirstFrom&#8203;(<a href="Walker.html" title="type parameter in Walker">N</a>...&nbsp;startNodes)</pre>
<div class="block">Starts from <code>startNodes</code> and walks in breadth-first order.

 <p>The returned stream may be infinite if the graph or tree has infinite depth or infinite
 breadth, or both. The stream can still be short-circuited to consume a limited number of
 nodes during traversal.</div>
</li>
</ul>
<a id="breadthFirstFrom(java.lang.Iterable)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>breadthFirstFrom</h4>
<pre class="methodSignature">public abstract&nbsp;java.util.stream.Stream&lt;<a href="Walker.html" title="type parameter in Walker">N</a>&gt;&nbsp;breadthFirstFrom&#8203;(java.lang.Iterable&lt;? extends <a href="Walker.html" title="type parameter in Walker">N</a>&gt;&nbsp;startNodes)</pre>
<div class="block">Starts from <code>startNodes</code> and walks in breadth-first order.

 <p>The returned stream may be infinite if the graph or tree has infinite depth or infinite
 breadth, or both. The stream can still be short-circuited to consume a limited number of
 nodes during traversal.</div>
</li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/Walker.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
<p class="legalCopy"><small>Copyright &#169; 2024. All rights reserved.</small></p>
</footer>
</body>
</html>
