<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (12.0.1) on Fri Mar 15 19:37:35 PDT 2024 -->
<title>Parallelizer (core 7.3-SNAPSHOT API)</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="dc.created" content="2024-03-15">
<link rel="stylesheet" type="text/css" href="../../../../../javadoc-stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../../jquery/jquery-ui.css" title="Style">
<script type="text/javascript" src="../../../../../script.js"></script>
<script type="text/javascript" src="../../../../../jquery/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../../../../jquery/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../../../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../../../../jquery/jquery-3.3.1.js"></script>
<script type="text/javascript" src="../../../../../jquery/jquery-migrate-3.0.1.js"></script>
<script type="text/javascript" src="../../../../../jquery/jquery-ui.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="Parallelizer (core 7.3-SNAPSHOT API)";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":10,"i1":9,"i2":10,"i3":10,"i4":10,"i5":10,"i6":10,"i7":10,"i8":10,"i9":10,"i10":10,"i11":10,"i12":10,"i13":10,"i14":9};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../../../../";
var useModuleDirectories = true;
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/Parallelizer.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<ul class="navListSearch">
<li><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</li>
</ul>
</div>
<a id="skip.navbar.top">
<!--   -->
</a>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">com.google.mu.util.concurrent</a></div>
<h2 title="Class Parallelizer" class="title">Class Parallelizer</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>com.google.mu.util.concurrent.Parallelizer</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<pre>public final class <span class="typeNameLabel">Parallelizer</span>
extends java.lang.Object</pre>
<div class="block">Utility to support <a href="https://en.wikipedia.org/wiki/Structured_concurrency">structured
 concurrency</a> for <em>IO-bound</em> subtasks of a single unit of work, while limiting the max
 concurrency.

 <p>For example, the following code saves a stream of <code>UserData</code> in parallel with at most 3
 concurrent RPC calls at the same time:

 <pre><code>
 new Parallelizer(executor, 3)
     .parallelize(userDataStream.filter(UserData::isModified), userService::save);
 </code></pre>

 <p>Similar to parallel streams (and unlike executors), these sub-tasks are considered integral
 parts of one unit of work. Failure of any sub-task aborts the entire work, automatically. If an
 exception isn't fatal, the sub-task should catch and handle it.

 <p>How does it stack against parallel stream itself?
 The parallel stream counterpart to the above example use case may look like:
 <pre>  <code>
   userDataStream.filter(UserData::isModified).parallel().forEach(userService::save);
 </code></pre>

 A few key differences: <ul>
 <li>A parallel stream doesn't use arbitrary <code>ExecutorService</code>. It by default uses
     either the enclosing <code>ForkJoinPool</code> or the common <code>ForkJoinPool</code> instance.
 <li>By running in a dedicated <code>ForkJoinPool</code>, a parallel stream can take a custom target
     concurrency, but it's not guaranteed to be <em>max</em> concurrency.
 <li>Parallel streams are for CPU-bound computations; while <code>Parallelizer</code> deals with
     IO-bound operations.
 <li><a href="#parallelize(java.util.stream.Stream,java.util.function.Consumer)"><code>parallelize()</code></a> can be interrupted, and can time out;
     parallel streams are uninterruptible.
 <li>When a task throws, <code>Parallelizer</code> dismisses pending tasks, and cancels all in-flight
     tasks (it's up to the user code to properly handle thread interruptions).
     So if a worker thread is waiting on some resource, it'll be interrupted without hanging
     the thread forever.
 <li><code>Parallelizer</code> wraps exceptions thrown by the worker threads, making stack trace
     clearer.
 </ul>

 <p>And how do you choose between <code>Parallelizer</code> and <code>ExecutorService</code>?
 Could you use something like the following instead?
 <pre>  <code>
   ExecutorService pool = Executors.newFixedThreadPool(3);
   try {
     List&lt;Future&lt;?&gt;&gt; futures = userData
         .filter(...)
         .map(() -&gt; pool.submit(() -&gt; userService.save(data)))
         .collect(toList());
     for (Future&lt;?&gt; future : futures) {
       future.get();
     }
   } finally {
     pool.shutdownNow();
   }
 </code></pre>

 Some differences for consideration:<ul>
 <li><b>Memory Concern</b>
     <ul>
     <li>The thread pool queues all pending tasks. For large streams (like reading hundreds
         of thousands of task input data from a file), it can run out of memory quickly.
      <li>Storing all the future objects in a list may also use up too much memory for large
          number of sub tasks.
     </ul>
 <li><b>Exception Handling (and fail fast)</b>
     <ul>
     <li>Executors treat submitted tasks as independent. One task may fail and the other tasks
         won't be affected.

         <p>But for co-dependent sub tasks that were parallelized only for performance reasons
         (as in parallel streams), you'll want to abort the whole parallel pipeline upon any
         critical exception, the same as if they were run sequentially.

         <p>Aborting a parallel pipeline requires complex concurrent logic to coordinate between
         the sub tasks and the executor in order to dismiss pending sub tasks and also to cancel
         sub tasks that are already running. Otherwise, when an exception is thrown from a sub
         task, the other left-over sub tasks will continue to run, some may even hang
         indefinitely.
     <li>Automatic cancellation propagation. When <a href="#parallelize(java.util.stream.Stream,java.util.function.Consumer)"><code>parallelize()</code></a> is
         interrupted, all running tasks will be automatically canceled; all pending tasks
         automatically dismissed.
     <li>You may resort to shutting down the executor to achieve similar result (cancelling the
         left-over sub tasks). Although even knowing whether a sub task has failed isn't trivial.
         The above code example uses <code>Future.get()</code>, but it won't help if a sub task
         submitted earlier is still running or being blocked, while a later-submitted sub task
         has failed.
     <li>And, <code>ExecutorService</code>s are often set up centrally and shared among different
         classes and components in the application. You may not have the option to create and
         shut down a thread pool of your own.
     </ul>
 </ul>

 <p>Stream parameters used in this class are always consumed in the calling thread and don't have
 to be thread safe.</div>
<dl>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>1.1</dd>
</dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<div class="memberSummary">
<table>
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Constructor</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tbody>
<tr class="altColor">
<th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E(java.util.concurrent.ExecutorService,int)">Parallelizer</a></span>&#8203;(java.util.concurrent.ExecutorService&nbsp;executor,
            int&nbsp;maxInFlight)</code></th>
<td class="colLast">
<div class="block">Constructs a <code>Parallelizer</code> that runs tasks with <code>executor</code>.</div>
</td>
</tr>
</tbody>
</table>
</div>
</li>
</ul>
</section>
<!-- ========== METHOD SUMMARY =========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<div class="memberSummary">
<div role="tablist" aria-orientation="horizontal"><button role="tab" aria-selected="true" aria-controls="memberSummary_tabpanel" tabindex="0" onkeydown="switchTab(event)" id="t0" class="activeTableTab">All Methods</button><button role="tab" aria-selected="false" aria-controls="memberSummary_tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t1" class="tableTab" onclick="show(1);">Static Methods</button><button role="tab" aria-selected="false" aria-controls="memberSummary_tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t2" class="tableTab" onclick="show(2);">Instance Methods</button><button role="tab" aria-selected="false" aria-controls="memberSummary_tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t4" class="tableTab" onclick="show(8);">Concrete Methods</button></div>
<div id="memberSummary_tabpanel" role="tabpanel">
<table aria-labelledby="t0">
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tbody>
<tr class="altColor" id="i0">
<td class="colFirst"><code>&lt;I,&#8203;O&gt;<br>java.util.stream.Collector&lt;I,&#8203;?,&#8203;<a href="../stream/BiStream.html" title="class in com.google.mu.util.stream">BiStream</a>&lt;I,&#8203;O&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#inParallel(java.util.function.Function)">inParallel</a></span>&#8203;(java.util.function.Function&lt;? super I,&#8203;? extends O&gt;&nbsp;concurrentFunction)</code></th>
<td class="colLast">
<div class="block">Returns a <code>Collector</code> that runs <code>concurrentFunction</code> in parallel using this <code>
 Parallelizer</code> and returns the inputs and outputs in a <a href="../stream/BiStream.html" title="class in com.google.mu.util.stream"><code>BiStream</code></a>, in encounter order of
 the input elements.</div>
</td>
</tr>
<tr class="rowColor" id="i1">
<td class="colFirst"><code>static <a href="Parallelizer.html" title="class in com.google.mu.util.concurrent">Parallelizer</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#newDaemonParallelizer(int)">newDaemonParallelizer</a></span>&#8203;(int&nbsp;maxInFlight)</code></th>
<td class="colLast">
<div class="block">Returns a new <a href="Parallelizer.html" title="class in com.google.mu.util.concurrent"><code>Parallelizer</code></a> based on an ExecutorService that exits when the application
 is complete.</div>
</td>
</tr>
<tr class="altColor" id="i2">
<td class="colFirst"><code>&lt;T&gt;&nbsp;void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#parallelize(java.util.Iterator,java.util.function.Consumer)">parallelize</a></span>&#8203;(java.util.Iterator&lt;? extends T&gt;&nbsp;inputs,
           java.util.function.Consumer&lt;? super T&gt;&nbsp;consumer)</code></th>
<td class="colLast">
<div class="block">Runs <code>consumer</code> for <code>inputs</code> in parallel and blocks until either all tasks have
 finished, or any exception is thrown upon which all pending tasks are canceled
 (but the method returns without waiting for the tasks to respond to cancellation).</div>
</td>
</tr>
<tr class="rowColor" id="i3">
<td class="colFirst"><code>&lt;T&gt;&nbsp;void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#parallelize(java.util.Iterator,java.util.function.Consumer,long,java.util.concurrent.TimeUnit)">parallelize</a></span>&#8203;(java.util.Iterator&lt;? extends T&gt;&nbsp;inputs,
           java.util.function.Consumer&lt;? super T&gt;&nbsp;consumer,
           long&nbsp;heartbeatTimeout,
           java.util.concurrent.TimeUnit&nbsp;timeUnit)</code></th>
<td class="colLast">
<div class="block">Runs <code>consumer</code> for <code>inputs</code> in parallel and blocks until either all tasks have
 finished, timeout is triggered, or any exception is thrown upon which all pending tasks are
 canceled (but the method returns without waiting for the tasks to respond to cancellation).</div>
</td>
</tr>
<tr class="altColor" id="i4">
<td class="colFirst"><code>&lt;T&gt;&nbsp;void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#parallelize(java.util.Iterator,java.util.function.Consumer,java.time.Duration)">parallelize</a></span>&#8203;(java.util.Iterator&lt;? extends T&gt;&nbsp;inputs,
           java.util.function.Consumer&lt;? super T&gt;&nbsp;consumer,
           java.time.Duration&nbsp;heartbeatTimeout)</code></th>
<td class="colLast">
<div class="block">Runs <code>consumer</code> for <code>inputs</code> in parallel and blocks until either all tasks have
 finished, timeout is triggered, or any exception is thrown upon which all pending tasks are
 canceled (but the method returns without waiting for the tasks to respond to cancellation).</div>
</td>
</tr>
<tr class="rowColor" id="i5">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#parallelize(java.util.stream.Stream)">parallelize</a></span>&#8203;(java.util.stream.Stream&lt;? extends java.lang.Runnable&gt;&nbsp;tasks)</code></th>
<td class="colLast">
<div class="block">Runs <code>tasks</code> in parallel and blocks until either all tasks have finished,
 or any exception is thrown upon which all pending tasks are canceled
 (but the method returns without waiting for the tasks to respond to cancellation).</div>
</td>
</tr>
<tr class="altColor" id="i6">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#parallelize(java.util.stream.Stream,long,java.util.concurrent.TimeUnit)">parallelize</a></span>&#8203;(java.util.stream.Stream&lt;? extends java.lang.Runnable&gt;&nbsp;tasks,
           long&nbsp;heartbeatTimeout,
           java.util.concurrent.TimeUnit&nbsp;timeUnit)</code></th>
<td class="colLast">
<div class="block">Runs <code>tasks</code> in parallel and blocks uninterruptibly until either all tasks have finished,
 timeout is triggered, or any exception is thrown upon which all pending tasks are canceled
 (but the method returns without waiting for the tasks to respond to cancellation).</div>
</td>
</tr>
<tr class="rowColor" id="i7">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#parallelize(java.util.stream.Stream,java.time.Duration)">parallelize</a></span>&#8203;(java.util.stream.Stream&lt;? extends java.lang.Runnable&gt;&nbsp;tasks,
           java.time.Duration&nbsp;heartbeatTimeout)</code></th>
<td class="colLast">
<div class="block">Runs <code>tasks</code> in parallel and blocks uninterruptibly until either all tasks have finished,
 timeout is triggered, or any exception is thrown upon which all pending tasks are canceled
 (but the method returns without waiting for the tasks to respond to cancellation).</div>
</td>
</tr>
<tr class="altColor" id="i8">
<td class="colFirst"><code>&lt;T&gt;&nbsp;void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#parallelize(java.util.stream.Stream,java.util.function.Consumer)">parallelize</a></span>&#8203;(java.util.stream.Stream&lt;? extends T&gt;&nbsp;inputs,
           java.util.function.Consumer&lt;? super T&gt;&nbsp;consumer)</code></th>
<td class="colLast">
<div class="block">Runs <code>consumer</code> for <code>inputs</code> in parallel and blocks until either all tasks have
 finished, or any exception is thrown upon which all pending tasks are canceled
 (but the method returns without waiting for the tasks to respond to cancellation).</div>
</td>
</tr>
<tr class="rowColor" id="i9">
<td class="colFirst"><code>&lt;T&gt;&nbsp;void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#parallelize(java.util.stream.Stream,java.util.function.Consumer,long,java.util.concurrent.TimeUnit)">parallelize</a></span>&#8203;(java.util.stream.Stream&lt;? extends T&gt;&nbsp;inputs,
           java.util.function.Consumer&lt;? super T&gt;&nbsp;consumer,
           long&nbsp;heartbeatTimeout,
           java.util.concurrent.TimeUnit&nbsp;timeUnit)</code></th>
<td class="colLast">
<div class="block">Runs <code>consumer</code> for <code>inputs</code> in parallel and blocks until either all tasks have
 finished, timeout is triggered, or any exception is thrown upon which all pending tasks are
 canceled (but the method returns without waiting for the tasks to respond to cancellation).</div>
</td>
</tr>
<tr class="altColor" id="i10">
<td class="colFirst"><code>&lt;T&gt;&nbsp;void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#parallelize(java.util.stream.Stream,java.util.function.Consumer,java.time.Duration)">parallelize</a></span>&#8203;(java.util.stream.Stream&lt;? extends T&gt;&nbsp;inputs,
           java.util.function.Consumer&lt;? super T&gt;&nbsp;consumer,
           java.time.Duration&nbsp;heartbeatTimeout)</code></th>
<td class="colLast">
<div class="block">Runs <code>consumer</code> for <code>inputs</code> in parallel and blocks until either all tasks have
 finished, timeout is triggered, or any exception is thrown upon which all pending tasks are
 canceled (but the method returns without waiting for the tasks to respond to cancellation).</div>
</td>
</tr>
<tr class="rowColor" id="i11">
<td class="colFirst"><code>&lt;T&gt;&nbsp;void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#parallelizeUninterruptibly(java.util.Iterator,java.util.function.Consumer)">parallelizeUninterruptibly</a></span>&#8203;(java.util.Iterator&lt;? extends T&gt;&nbsp;inputs,
                          java.util.function.Consumer&lt;? super T&gt;&nbsp;consumer)</code></th>
<td class="colLast">
<div class="block">Runs <code>consumer</code> for <code>inputs</code> in parallel and blocks uninterruptibly until
 either all tasks have finished, or any exception is thrown upon which all pending tasks are
 canceled (but the method returns without waiting for the tasks to respond to cancellation).</div>
</td>
</tr>
<tr class="altColor" id="i12">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#parallelizeUninterruptibly(java.util.stream.Stream)">parallelizeUninterruptibly</a></span>&#8203;(java.util.stream.Stream&lt;? extends java.lang.Runnable&gt;&nbsp;tasks)</code></th>
<td class="colLast">
<div class="block">Runs <code>tasks</code> in parallel and blocks uninterruptibly until either all tasks have finished,
 or any exception is thrown upon which all pending tasks are canceled
 (but the method returns without waiting for the tasks to respond to cancellation).</div>
</td>
</tr>
<tr class="rowColor" id="i13">
<td class="colFirst"><code>&lt;T&gt;&nbsp;void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#parallelizeUninterruptibly(java.util.stream.Stream,java.util.function.Consumer)">parallelizeUninterruptibly</a></span>&#8203;(java.util.stream.Stream&lt;? extends T&gt;&nbsp;inputs,
                          java.util.function.Consumer&lt;? super T&gt;&nbsp;consumer)</code></th>
<td class="colLast">
<div class="block">Runs <code>consumer</code> for <code>inputs</code> in parallel and blocks uninterruptibly until
 either all tasks have finished, or any exception is thrown upon which all pending tasks are
 canceled (but the method returns without waiting for the tasks to respond to cancellation).</div>
</td>
</tr>
<tr class="altColor" id="i14">
<td class="colFirst"><code>static <a href="Parallelizer.html" title="class in com.google.mu.util.concurrent">Parallelizer</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#virtualThreadParallelizer(int)">virtualThreadParallelizer</a></span>&#8203;(int&nbsp;maxInFlight)</code></th>
<td class="colLast">
<div class="block">Returns a <a href="Parallelizer.html" title="class in com.google.mu.util.concurrent"><code>Parallelizer</code></a> using virtual threads for running tasks, with at most
 <code>maxInFlight</code> tasks running concurrently.</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a id="&lt;init&gt;(java.util.concurrent.ExecutorService,int)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>Parallelizer</h4>
<pre>public&nbsp;Parallelizer&#8203;(java.util.concurrent.ExecutorService&nbsp;executor,
                    int&nbsp;maxInFlight)</pre>
<div class="block">Constructs a <code>Parallelizer</code> that runs tasks with <code>executor</code>.
 At any given time, at most <code>maxInFlight</code> tasks are allowed to be submitted to
 <code>executor</code>.

 <p>Note that a task being submitted to <code>executor</code> doesn't guarantee immediate
 execution, if for example all worker threads in <code>executor</code> are busy.</div>
</li>
</ul>
</li>
</ul>
</section>
<!-- ============ METHOD DETAIL ========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a id="virtualThreadParallelizer(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>virtualThreadParallelizer</h4>
<pre class="methodSignature">public static&nbsp;<a href="Parallelizer.html" title="class in com.google.mu.util.concurrent">Parallelizer</a>&nbsp;virtualThreadParallelizer&#8203;(int&nbsp;maxInFlight)</pre>
<div class="block">Returns a <a href="Parallelizer.html" title="class in com.google.mu.util.concurrent"><code>Parallelizer</code></a> using virtual threads for running tasks, with at most
 <code>maxInFlight</code> tasks running concurrently.

 <p>Only applicable in JDK 21 (throws if below JDK 21).</div>
<dl>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>7.2</dd>
</dl>
</li>
</ul>
<a id="newDaemonParallelizer(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>newDaemonParallelizer</h4>
<pre class="methodSignature">public static&nbsp;<a href="Parallelizer.html" title="class in com.google.mu.util.concurrent">Parallelizer</a>&nbsp;newDaemonParallelizer&#8203;(int&nbsp;maxInFlight)</pre>
<div class="block">Returns a new <a href="Parallelizer.html" title="class in com.google.mu.util.concurrent"><code>Parallelizer</code></a> based on an ExecutorService that exits when the application
 is complete. It does so by using daemon threads.

 <p>Typically used by the <code>main()</code> method or as a static final field.</div>
<dl>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>6.5</dd>
</dl>
</li>
</ul>
<a id="parallelize(java.util.stream.Stream,java.util.function.Consumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>parallelize</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;void&nbsp;parallelize&#8203;(java.util.stream.Stream&lt;? extends T&gt;&nbsp;inputs,
                            java.util.function.Consumer&lt;? super T&gt;&nbsp;consumer)
                     throws java.lang.InterruptedException</pre>
<div class="block">Runs <code>consumer</code> for <code>inputs</code> in parallel and blocks until either all tasks have
 finished, or any exception is thrown upon which all pending tasks are canceled
 (but the method returns without waiting for the tasks to respond to cancellation).

 <p>The <code>inputs</code> stream is consumed only in the calling thread in iteration order.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>inputs</code> - the inputs to be passed to <code>consumer</code></dd>
<dd><code>consumer</code> - to be parallelized</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.InterruptedException</code> - if the thread is interrupted while waiting.</dd>
</dl>
</li>
</ul>
<a id="parallelize(java.util.Iterator,java.util.function.Consumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>parallelize</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;void&nbsp;parallelize&#8203;(java.util.Iterator&lt;? extends T&gt;&nbsp;inputs,
                            java.util.function.Consumer&lt;? super T&gt;&nbsp;consumer)
                     throws java.lang.InterruptedException</pre>
<div class="block">Runs <code>consumer</code> for <code>inputs</code> in parallel and blocks until either all tasks have
 finished, or any exception is thrown upon which all pending tasks are canceled
 (but the method returns without waiting for the tasks to respond to cancellation).

 <p>The <code>inputs</code> stream is consumed only in the calling thread in iteration order.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>inputs</code> - the inputs to be passed to <code>consumer</code></dd>
<dd><code>consumer</code> - to be parallelized</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.InterruptedException</code> - if the thread is interrupted while waiting.</dd>
</dl>
</li>
</ul>
<a id="parallelize(java.util.stream.Stream,java.util.function.Consumer,java.time.Duration)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>parallelize</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;void&nbsp;parallelize&#8203;(java.util.stream.Stream&lt;? extends T&gt;&nbsp;inputs,
                            java.util.function.Consumer&lt;? super T&gt;&nbsp;consumer,
                            java.time.Duration&nbsp;heartbeatTimeout)
                     throws java.util.concurrent.TimeoutException,
                            java.lang.InterruptedException</pre>
<div class="block">Runs <code>consumer</code> for <code>inputs</code> in parallel and blocks until either all tasks have
 finished, timeout is triggered, or any exception is thrown upon which all pending tasks are
 canceled (but the method returns without waiting for the tasks to respond to cancellation).

 <p>The <code>inputs</code> stream is consumed only in the calling thread in iteration order.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>inputs</code> - the inputs to be passed to <code>consumer</code></dd>
<dd><code>consumer</code> - to be parallelized</dd>
<dd><code>heartbeatTimeout</code> - at least one task needs to complete every <code>heartbeatTimeout</code>.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.InterruptedException</code> - if the thread is interrupted while waiting.</dd>
<dd><code>java.util.concurrent.TimeoutException</code> - if the configured timeout is exceeded while waiting.</dd>
</dl>
</li>
</ul>
<a id="parallelize(java.util.stream.Stream,java.util.function.Consumer,long,java.util.concurrent.TimeUnit)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>parallelize</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;void&nbsp;parallelize&#8203;(java.util.stream.Stream&lt;? extends T&gt;&nbsp;inputs,
                            java.util.function.Consumer&lt;? super T&gt;&nbsp;consumer,
                            long&nbsp;heartbeatTimeout,
                            java.util.concurrent.TimeUnit&nbsp;timeUnit)
                     throws java.util.concurrent.TimeoutException,
                            java.lang.InterruptedException</pre>
<div class="block">Runs <code>consumer</code> for <code>inputs</code> in parallel and blocks until either all tasks have
 finished, timeout is triggered, or any exception is thrown upon which all pending tasks are
 canceled (but the method returns without waiting for the tasks to respond to cancellation).

 <p>The <code>inputs</code> stream is consumed only in the calling thread in iteration order.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>inputs</code> - the inputs to be passed to <code>consumer</code></dd>
<dd><code>consumer</code> - to be parallelized</dd>
<dd><code>heartbeatTimeout</code> - at least one task needs to complete every <code>heartbeatTimeout</code>.</dd>
<dd><code>timeUnit</code> - the unit of <code>heartbeatTimeout</code></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.InterruptedException</code> - if the thread is interrupted while waiting.</dd>
<dd><code>java.util.concurrent.TimeoutException</code> - if the configured timeout is exceeded while waiting.</dd>
</dl>
</li>
</ul>
<a id="parallelize(java.util.Iterator,java.util.function.Consumer,java.time.Duration)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>parallelize</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;void&nbsp;parallelize&#8203;(java.util.Iterator&lt;? extends T&gt;&nbsp;inputs,
                            java.util.function.Consumer&lt;? super T&gt;&nbsp;consumer,
                            java.time.Duration&nbsp;heartbeatTimeout)
                     throws java.util.concurrent.TimeoutException,
                            java.lang.InterruptedException</pre>
<div class="block">Runs <code>consumer</code> for <code>inputs</code> in parallel and blocks until either all tasks have
 finished, timeout is triggered, or any exception is thrown upon which all pending tasks are
 canceled (but the method returns without waiting for the tasks to respond to cancellation).

 <p>The <code>inputs</code> stream is consumed only in the calling thread in iteration order.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>inputs</code> - the inputs to be passed to <code>consumer</code></dd>
<dd><code>consumer</code> - to be parallelized</dd>
<dd><code>heartbeatTimeout</code> - at least one task needs to complete every <code>heartbeatTimeout</code>.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.InterruptedException</code> - if the thread is interrupted while waiting.</dd>
<dd><code>java.util.concurrent.TimeoutException</code> - if the configured timeout is exceeded while waiting.</dd>
</dl>
</li>
</ul>
<a id="parallelize(java.util.Iterator,java.util.function.Consumer,long,java.util.concurrent.TimeUnit)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>parallelize</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;void&nbsp;parallelize&#8203;(java.util.Iterator&lt;? extends T&gt;&nbsp;inputs,
                            java.util.function.Consumer&lt;? super T&gt;&nbsp;consumer,
                            long&nbsp;heartbeatTimeout,
                            java.util.concurrent.TimeUnit&nbsp;timeUnit)
                     throws java.util.concurrent.TimeoutException,
                            java.lang.InterruptedException</pre>
<div class="block">Runs <code>consumer</code> for <code>inputs</code> in parallel and blocks until either all tasks have
 finished, timeout is triggered, or any exception is thrown upon which all pending tasks are
 canceled (but the method returns without waiting for the tasks to respond to cancellation).

 <p>The <code>inputs</code> stream is consumed only in the calling thread in iteration order.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>inputs</code> - the inputs to be passed to <code>consumer</code></dd>
<dd><code>consumer</code> - to be parallelized</dd>
<dd><code>heartbeatTimeout</code> - at least one task needs to complete every <code>heartbeatTimeout</code>.</dd>
<dd><code>timeUnit</code> - the unit of <code>heartbeatTimeout</code></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.InterruptedException</code> - if the thread is interrupted while waiting.</dd>
<dd><code>java.util.concurrent.TimeoutException</code> - if the configured timeout is exceeded while waiting.</dd>
</dl>
</li>
</ul>
<a id="parallelizeUninterruptibly(java.util.stream.Stream,java.util.function.Consumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>parallelizeUninterruptibly</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;void&nbsp;parallelizeUninterruptibly&#8203;(java.util.stream.Stream&lt;? extends T&gt;&nbsp;inputs,
                                           java.util.function.Consumer&lt;? super T&gt;&nbsp;consumer)</pre>
<div class="block">Runs <code>consumer</code> for <code>inputs</code> in parallel and blocks uninterruptibly until
 either all tasks have finished, or any exception is thrown upon which all pending tasks are
 canceled (but the method returns without waiting for the tasks to respond to cancellation).

 <p>The <code>inputs</code> stream is consumed only in the calling thread in iteration order.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>inputs</code> - the inputs to be passed to <code>consumer</code></dd>
<dd><code>consumer</code> - to be parallelized</dd>
</dl>
</li>
</ul>
<a id="parallelizeUninterruptibly(java.util.Iterator,java.util.function.Consumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>parallelizeUninterruptibly</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;void&nbsp;parallelizeUninterruptibly&#8203;(java.util.Iterator&lt;? extends T&gt;&nbsp;inputs,
                                           java.util.function.Consumer&lt;? super T&gt;&nbsp;consumer)</pre>
<div class="block">Runs <code>consumer</code> for <code>inputs</code> in parallel and blocks uninterruptibly until
 either all tasks have finished, or any exception is thrown upon which all pending tasks are
 canceled (but the method returns without waiting for the tasks to respond to cancellation).

 <p>The <code>inputs</code> stream is consumed only in the calling thread in iteration order.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>inputs</code> - the inputs to be passed to <code>consumer</code></dd>
<dd><code>consumer</code> - to be parallelized</dd>
</dl>
</li>
</ul>
<a id="parallelize(java.util.stream.Stream)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>parallelize</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;parallelize&#8203;(java.util.stream.Stream&lt;? extends java.lang.Runnable&gt;&nbsp;tasks)
                 throws java.lang.InterruptedException</pre>
<div class="block">Runs <code>tasks</code> in parallel and blocks until either all tasks have finished,
 or any exception is thrown upon which all pending tasks are canceled
 (but the method returns without waiting for the tasks to respond to cancellation).

 <p>The <code>tasks</code> stream is consumed only in the calling thread in iteration order.</div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.InterruptedException</code> - if the thread is interrupted while waiting.</dd>
</dl>
</li>
</ul>
<a id="parallelize(java.util.stream.Stream,java.time.Duration)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>parallelize</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;parallelize&#8203;(java.util.stream.Stream&lt;? extends java.lang.Runnable&gt;&nbsp;tasks,
                        java.time.Duration&nbsp;heartbeatTimeout)
                 throws java.util.concurrent.TimeoutException,
                        java.lang.InterruptedException</pre>
<div class="block">Runs <code>tasks</code> in parallel and blocks uninterruptibly until either all tasks have finished,
 timeout is triggered, or any exception is thrown upon which all pending tasks are canceled
 (but the method returns without waiting for the tasks to respond to cancellation).

 <p>The <code>tasks</code> stream is consumed only in the calling thread in iteration order.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>tasks</code> - the tasks to be parallelized</dd>
<dd><code>heartbeatTimeout</code> - at least one task needs to complete every <code>heartbeatTimeout</code>.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.InterruptedException</code> - if the thread is interrupted while waiting.</dd>
<dd><code>java.util.concurrent.TimeoutException</code> - if timeout exceeded while waiting.</dd>
</dl>
</li>
</ul>
<a id="parallelize(java.util.stream.Stream,long,java.util.concurrent.TimeUnit)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>parallelize</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;parallelize&#8203;(java.util.stream.Stream&lt;? extends java.lang.Runnable&gt;&nbsp;tasks,
                        long&nbsp;heartbeatTimeout,
                        java.util.concurrent.TimeUnit&nbsp;timeUnit)
                 throws java.util.concurrent.TimeoutException,
                        java.lang.InterruptedException</pre>
<div class="block">Runs <code>tasks</code> in parallel and blocks uninterruptibly until either all tasks have finished,
 timeout is triggered, or any exception is thrown upon which all pending tasks are canceled
 (but the method returns without waiting for the tasks to respond to cancellation).

 <p>The <code>tasks</code> stream is consumed only in the calling thread in iteration order.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>tasks</code> - the tasks to be parallelized</dd>
<dd><code>heartbeatTimeout</code> - at least one task needs to complete every <code>heartbeatTimeout</code>.</dd>
<dd><code>timeUnit</code> - the unit of <code>heartbeatTimeout</code></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.InterruptedException</code> - if the thread is interrupted while waiting.</dd>
<dd><code>java.util.concurrent.TimeoutException</code> - if timeout exceeded while waiting.</dd>
</dl>
</li>
</ul>
<a id="parallelizeUninterruptibly(java.util.stream.Stream)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>parallelizeUninterruptibly</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;parallelizeUninterruptibly&#8203;(java.util.stream.Stream&lt;? extends java.lang.Runnable&gt;&nbsp;tasks)</pre>
<div class="block">Runs <code>tasks</code> in parallel and blocks uninterruptibly until either all tasks have finished,
 or any exception is thrown upon which all pending tasks are canceled
 (but the method returns without waiting for the tasks to respond to cancellation).</div>
</li>
</ul>
<a id="inParallel(java.util.function.Function)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>inParallel</h4>
<pre class="methodSignature">public&nbsp;&lt;I,&#8203;O&gt;&nbsp;java.util.stream.Collector&lt;I,&#8203;?,&#8203;<a href="../stream/BiStream.html" title="class in com.google.mu.util.stream">BiStream</a>&lt;I,&#8203;O&gt;&gt;&nbsp;inParallel&#8203;(java.util.function.Function&lt;? super I,&#8203;? extends O&gt;&nbsp;concurrentFunction)</pre>
<div class="block">Returns a <code>Collector</code> that runs <code>concurrentFunction</code> in parallel using this <code>
 Parallelizer</code> and returns the inputs and outputs in a <a href="../stream/BiStream.html" title="class in com.google.mu.util.stream"><code>BiStream</code></a>, in encounter order of
 the input elements.

 <p>For example: <pre><code>
 ImmutableListMultimap&lt;String, Asset&gt; resourceAssets =
     resources.stream()
         .collect(parallelizer.inParallel(this::listAssets))
         .collect(flatteningToImmutableListMultimap(List::stream));
 </code></pre>

 <p>In Java 20 using structured concurrency, it can be implemented equivalently as in:
 <pre><code>
 ImmutableListMultimap&lt;String, Asset&gt; resourceAssets;
 try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {
   ImmutableList&lt;Future&lt;?&gt;&gt; results =
       resources.stream()
           .map(resource -&gt; scope.fork(() -&gt; listAssets(resource)))
           .collect(toImmutableList());
   scope.join();
   resourceAssets =
       BiStream.zip(resources, results)
           .mapValues(Future::resultNow)
           .collect(flatteningToImmutableListMultimap(List::stream));
 }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>concurrentFunction</code> - a function that's safe to be run concurrently, and is usually
     IO-intensive (such as an outgoing RPC or reading distributed storage).</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>6.5</dd>
</dl>
</li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/Parallelizer.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
<p class="legalCopy"><small>Copyright &#169; 2024. All rights reserved.</small></p>
</footer>
</body>
</html>
